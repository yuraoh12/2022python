# 리스트, 딕셔너리 -> 데이터 관리를 편하게 -> 코드 관리를 편하게 하기 위해
# 현실 세계 반영 -> 사물이나 개념. => 복잡한 정보로 이루어짐.
# ex) 회원 -> 이름, 주소, 아이디, 비밀번호 .....
# ex) 강아지 -> 이름, 나이, 품종 ....

# 사물은 데이터와 데이터를 처리하는 함수로 이루어진다.
# 사람이 움직인다. -> 사람의 좌표정보를 처리 0, 0  -> 5, 0. 좌표는 데이터, 좌표의 연산은 데이터 처리(연산)

# # 구조화된 데이터 -> 자료구조
# age = 22
# name = "홍길순"
# address = "대전"

# # 자료구조를 처리하는 함수
# def introduce(age, name, address) :
#     print("안녕하세요 {} 사는 {}살 {}입니다.".format(address, age, name))

# 클래스 -> 같은 성격의 자료구조와 그 자료구조를 처리하는 함수를 따로 모아놓은 것. 
#       -> 데이터(속성), 데이터를 처리하는 함수(기능,동작) 
#       -> 사물이나 개념을 표현.

# 설계도로써, 틀로써 사용하고싶은 class
class Person :

    # 사람 자료구조
    age = 22
    name = "홍길순"
    address = "대전"

    # 사람 자료구조를 이용한 함수
    # 자신이 가진 데이터를 사용할 때는 self라는 매개변수를 사용한다.
    def introduce(self) :
        print("안녕하세요 {} 사는 {}살 {}입니다.".format(self.address, self.age, self.name))

# 클래스는 설계도,틀이고 객체(인스턴스)는 복사본. 
# 클래스() 명령어를 이용해 복사본을 생성할 수 있다. 복사본은 이름이 없기 때문에 변수를 이용해 식별.
p1 = Person() # 복사본1
p2 = Person() # 복사본2
p3 = Person() # 복사본3

# 복사본2를 홍길동 정보를 저장하는데 사용
p2.age = 20
p2.name = "홍길동"
p2.address = "서울"

# 복사본3를 임꺽정 정보를 저장하는데 사용
p3.age = 30
p3.name = "임꺽정"
p3.address = "광주"

# 객체의 메서드를 호출하기 위해서는 메서드를 호출하는 주체를 앞에 적어줘야 한다.
# 객체를 이용해 메서드를 호출. 이때 자신의 데이터를 사용할 때는 자신을 인수로 넘기지 않아도 된다. 스스로 데이터를 가지고 있기 때문에
p2.introduce()
p3.introduce()